---
title: "seeds-Amani"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(boot)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
alpha0 <- 0
alpha1 <- 0
alpha2 <- 0
alpha12 <- 0
tau <- 10
b <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0)
"N" <- 
21
"r" <-
c(10, 23, 23, 26, 17, 5, 53, 55, 32, 46, 10, 8, 10, 8, 23, 0, 
3, 22, 15, 32, 3)
"n" <-
c(39, 62, 81, 51, 39, 6, 74, 72, 51, 79, 13, 16, 30, 28, 45, 
4, 12, 41, 30, 51, 7)
"x1" <-
c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1)
"x2" <-
c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 
1)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}

gibbs_Seeds <- function(nchain , n , r , N , X1, X2 , prop_sd = 1) {
  
  alpha0 <- 0
  alpha1 <- 0
  alpha2 <- 0
  alpha12 <- 0
  sigma2 <- 1/10
  b <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0)

  p = inv.logit(alpha0 + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
  
  chain <- matrix(NA , nchain +1 , 5 )
  
  b_chain <- matrix(NA , nchain +1 , N )
  
  chain[1,] <- c(alpha0 , alpha1 , alpha2 , alpha12 , sigma2)
  
  b_chain[1,] <- b
  
  for (i in 1:nchain){
    
    # Mise a jour de alpha0
    
    prop <- rnorm(1, alpha0, prop_sd)
    
    prop_p <- inv.logit(prop + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
    
    top <- prop * sum(r) + sum(n*log(1-prop_p)) - (prop**2/2*1000000)
    
    bottom <- alpha0 * sum(r) + sum(n*log(1-p)) - (alpha0**2/2*1000000)
    
    acc_prop = exp(top-bottom)
    
    if (runif(1) < acc_prop){
      alpha0 <- prop
      p <- prop_p
    }
    
    ## Mise a jour de alpha1
    
    prop <- rnorm(1, alpha1, prop_sd)
    
    prop_p <- inv.logit(alpha0 + prop * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b)
    
    top <- prop * sum(r*x1) + sum(n*log(1-prop_p)) - (prop**2/2*1000000)
    
    bottom <- alpha1 * sum(r*x1) + sum(n*log(1-p)) - (alpha1**2/2*1000000)
    
    acc_prop = exp(top-bottom)
    
    
    if (runif(1) < acc_prop){
      alpha1 <- prop
      p <- prop_p
    }
    
        ## Mise a jour de alpha2
    
    prop <- rnorm(1, alpha2, prop_sd)
    
    prop_p <- inv.logit(alpha0 + alpha1 * x1 + prop * x2 + alpha12 * x1 * x2 + b)
    
    top <- prop * sum(r*x2) + sum(n*log(1-prop_p)) - (prop**2/2*1000000)
    
    bottom <- alpha2 * sum(r*x2) + sum(n*log(1-p)) - (alpha2**2/2*1000000)
    
    acc_prop = exp(top-bottom)
     

    if (runif(1) < acc_prop){
      alpha2 <- prop
      p <- prop_p
    }
    
        ## Mise a jour de alpha12
    
    prop <- rnorm(1, alpha12, prop_sd)
    
    prop_p <- inv.logit(alpha0 + alpha1 * x1 + alpha2 * x2 + prop * x1 * x2 + b)
    
    top <- prop * sum((r*x1)*x2) + sum(n*log(1-prop_p)) - (prop**2/2*1000000)
    
    bottom <- alpha12 * sum((r*x1)*x2) + sum(n*log(1-p)) - (alpha12**2/2*1000000)
    
    acc_prop = exp(top-bottom)
     

    if (runif(1) < acc_prop){
      alpha12 <- prop
      p <- prop_p
    }
    
            ## Mise a jour de sigma2
    
    prop <- rnorm(1, sigma2, prop_sd)
    
    top <- (1.001+N/2)*log(prop) - (0.001 + 0.5 * sum(b**2))/prop
    
    bottom <- (1.001+N/2)*log(sigma2) - (0.001 + 0.5 * sum(b**2))/sigma2
    
    acc_prop = exp(top-bottom)
    
    if (runif(1) < acc_prop){
      sigma2 <- prop
      p <- prop_p
    }
    
            ## Mise a jour de b
    

    for (j in 1:N) {
      ## Mise a jour de bi
      prop <- rnorm(1, b[j], prop_sd)
    
      prop_p <- inv.logit(alpha0 + alpha1 * x1[j] + alpha2 * x2[j] + alpha12 * x1[j] * x2[j] + prop)
    
      top <- -(0.5 * prop^2) / sigma2 + (r[j]* prop) + (n[j] * log(1-prop_p))
    
      bottom <- -(0.5 * b[j]^2) / sigma2 + (r[j]* b[j]) + (n[j] * log(1-p))
    
      acc_prop = exp(top-bottom)
       
      
      if (runif(1) < acc_prop){
        b[j] <- prop
        p[j] <- prop_p
      }
      }
    
    ## Mettre a jour ma chaine
    chain[i+1,] <- c(alpha0 , alpha1 , alpha2 , alpha12 , sigma2)
    b_chain[i+1,] <- b
  }
  return(chain,b_chain)
  }
  
```

```{r}
x <- gibbs_Seeds(10000 , n , r , N , X1, X2 , prop_sd = 1)
summary(x)
```
```{r}
burnin <- 1:5000 
plot(mcmc(x[-burnin,]))
```



Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
