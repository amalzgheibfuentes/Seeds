---
title: "Seeds: Random effect logistic regression"
---

```{r}
require(invgamma)
```


# Préparation des données

```{r}
"N"  <- 21
"r"  <- c(10, 23, 23, 26, 17, 5, 53, 55, 32, 46, 10, 8, 10, 8, 23, 0, 3, 22, 15, 32, 3)
"n"  <- c(39, 62, 81, 51, 39, 6, 74, 72, 51, 79, 13, 16, 30, 28, 45, 4, 12, 41, 30, 51, 7) 
"x1" <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
"x2" <- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
```

```{r}
df <- data.frame(r,n,r/n,x1,x2)
```

```{r}
alpha0   <- 0
alpha1   <- 0
alpha2   <- 0
alpha12  <- 0
tau      <- 10
b        <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
```

```{r}
init <- list(alpha0, alpha1, alpha2, alpha12, tau, b)
```

```{r}
par <- c(10^3, 10^3, 10^3, 10^3, 10^(-3), 10^(-3))
prop_sd <- c(1, 1, 1, 1, 1, 1)
```


# Model

```{r}
gibbsSeeds <- function(nchain, df, init, par, prop_sd) {
  
  # Data
  N   <- nrow(df)
  r   <- df$r
  n   <- df$n
  x1  <- df$x1
  x2  <- df$x2
  
  # Init
  alpha0  <- init[[1]]
  alpha1  <- init[[2]]
  alpha2  <- init[[3]]
  alpha12 <- init[[4]]
  tau     <- init[[5]]
  b       <- init[[6]]
  
  sigma   <- 1 / sqrt(tau)
  
  p <- exp(alpha0 + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b) /
    (1 + exp(alpha0 + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b))
  
  # Param for all plates
  chain     <- matrix(NA, nchain + 1, 5)
  chain[1,] <- c(alpha0, alpha1, alpha2, alpha12, sigma)
  # Param for each plate
  chain_b     <- matrix(NA, nchain + 1, length(b))
  chain_b[1,] <- b
  
  for (i in 1:nchain){
    
    # Mise a jour de alpha0
    
    ## propsicion de alpha0 y calculo de p ligado 
    prop <- rnorm(1, alpha0, prop_sd[1])       
    prop_p <- exp(prop + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b) /
    (1 + exp(prop + alpha1 * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b))
    
    ## ley condicional evaluada en los valores propuestos
    top <- - prop^2 / (2*par[1]^2) + sum(r*log(prop_p)) + sum((n-r)*log(1-prop_p))
    
    ## ley condicional evaluada en los valores iniciales
    bottom <- alpha0^2 / (2*par[1]^2) + sum(r*log(p)) + sum((n-r)*log(1-p))
    
    acc_prob <- exp(top - bottom)
    
    if (runif(1) < acc_prob){
      alpha0 <- prop
      p <- prop_p
    }
    
    print('alpha0')
    
    #---------------------------------------------------------------------------
    
    # Mise a jour de alpha1
    
    ## propsicion de alpha1 y calculo de p ligado 
    prop <- rnorm(1, alpha1, prop_sd[2])       
    prop_p <- exp(alpha0 + prop * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b) /
    (1 + exp(alpha0 + prop * x1 + alpha2 * x2 + alpha12 * x1 * x2 + b))
    
    ## ley condicional evaluada en los valores propuestos
    top <- - prop^2 / (2*par[2]^2) + sum(r*log(prop_p)) + sum((n-r)*log(1-prop_p))
    
    ## ley condicional evaluada en los valores iniciales
    bottom <- alpha1^2 / (2*par[2]^2) + sum(r*log(p)) + sum((n-r)*log(1-p))
    
    acc_prob <- exp(top - bottom)
    
    if (runif(1) < acc_prob){
      alpha1 <- prop
    }
    print('alpha1')
    
    #---------------------------------------------------------------------------
    
    # Mise a jour de alpha2
    
    ## propsicion de alpha2 y calculo de p ligado 
    prop <- rnorm(1, alpha2, prop_sd[3])       
    prop_p <- exp(alpha0 + alpha1 * x1 + prop * x2 + alpha12 * x1 * x2 + b) /
    (1 + exp(alpha0 + alpha1 * x1 + prop * x2 + alpha12 * x1 * x2 + b))
    
    ## ley condicional evaluada en los valores propuestos
    top <- - prop^2 / (2*par[3]^2) + sum(r*log(prop_p)) + sum((n-r)*log(1-prop_p))
    
    ## ley condicional evaluada en los valores iniciales
    bottom <- alpha2^2 / (2*par[3]^2) + sum(r*log(p)) + sum((n-r)*log(1-p))
    
    acc_prob <- exp(top - bottom)
    
    if (runif(1) < acc_prob){
      alpha2 <- prop
    }
    print('alpha2')
    #---------------------------------------------------------------------------
    
    # Mise a jour de alpha12
    
    ## propsicion de alpha12 y calculo de p ligado 
    prop <- rnorm(1, alpha12, prop_sd[4])       
    prop_p <- exp(alpha0 + alpha1 * x1 + alpha2 * x2 + prop * x1 * x2 + b) /
    (1 + exp(alpha0 + alpha1 * x1 + alpha2 * x2 + prop * x1 * x2 + b))
    
    ## ley condicional evaluada en los valores propuestos
    top <- - prop^2 / (2*par[4]^2) + sum(r*log(prop_p)) + sum((n-r)*log(1-prop_p))
    
    ## ley condicional evaluada en los valores iniciales
    bottom <- alpha12^2 / (2*par[4]^2) + sum(r*log(p)) + sum((n-r)*log(1-p))
    
    acc_prob <- exp(top - bottom)
    
    if (runif(1) < acc_prob){
      alpha12 <- prop
    }
    print('alpha12')
    
    #---------------------------------------------------------------------------
    
    # Mise a jour de sigma carre
    
    sigma <- rinvgamma(1, par[5] + N/2, par[6] + 0.5 * sum(b^2))
    
    #---------------------------------------------------------------------------
    
    # Mise a jour de b
    
    for (j in 1:N) {
      ## proposicion de b_j
      prop <- rnorm(1, b[j], prop_sd[6])
      prop_p <- exp(alpha0 + alpha1 * x1[j] + alpha2 * x2[j] + alpha12 * x1[j] * x2[j] + prop) /
    (1 + exp(alpha0 + alpha1 * x1[j] + alpha2 * x2[j] + alpha12 * x1[j] * x2[j] + prop))
      
      ## ley condicional evaluada en los valores propuestos
      top <- - prop^2 / (2*sigma^2) + r[j]*log(prop_p) + (n[j] - r[j]) * log(1-prop_p)
      
      ## ley condicional evaluada en los valores iniciales
      bottom <- - b[j]^2 / (2*sigma^2) + r[j]*log(p[j]) + (n[j] - r[j]) * log(1-p[j])
      
      acc_prob <- exp(top - bottom)
      
      if (runif(1) < acc_prob){
        b[j] <- prop
        p[j] <- prop_p

      }
      print(j)
    }
    
    #---------------------------------------------------------------------------
    
    ## Mettre a jour la chaine
    chain[i+1,]   <- c(alpha0, alpha1, alpha2, alpha12, sigma)
    chain_b[i+1,] <- b
  }
  
  return(list(chain, chain_b))
}
```

# Résultats

```{r}
chains <- gibbsSeeds(nchain = 10^4, df = df, init = init, par = par, prop_sd = prop_sd)
```




